# 智能闹钟应用 - 代码架构与调用关系说明

## 一、项目结构概览

```
com.example.myapplication/
├── MainActivity.java              # 主界面：显示闹钟列表
├── EditAlarmActivity.java         # 编辑闹钟界面：添加/编辑闹钟
├── AlarmRingingActivity.java      # 闹钟响铃界面：响铃时的交互界面
├── SettingsActivity.java          # 设置界面：全局设置管理
├── SnoozeSettingsActivity.java    # 稍后提醒设置界面
├── model/
│   └── Alarm.java                 # 闹钟数据模型
├── manager/
│   └── AlarmDataManager.java      # 闹钟数据管理：CRUD + 系统闹钟调度
├── receiver/
│   └── AlarmReceiver.java         # 广播接收器：接收系统闹钟触发
├── adapter/
│   └── AlarmAdapter.java          # 列表适配器：显示闹钟列表
└── util/
    └── HolidayUtil.java           # 节假日工具：查询API判断是否为节假日
```

---

## 二、核心数据流

### 2.1 闹钟创建流程

```
用户操作: 点击"+"按钮
    ↓
MainActivity.openEditAlarmActivity(null)
    ↓
EditAlarmActivity.onCreate()
    ↓
用户填写闹钟信息并点击"完成"
    ↓
EditAlarmActivity.saveAlarm()
    ↓
AlarmDataManager.addAlarm(Alarm)
    ├─→ 保存到 SharedPreferences (alarm_prefs)
    └─→ AlarmDataManager.scheduleAlarm(Alarm)
        ├─→ 检查跳过节假日设置（全局/单个）
        ├─→ HolidayUtil.isHoliday() 查询API
        └─→ AlarmManager.setExactAndAllowWhileIdle() 注册系统闹钟
```

### 2.2 闹钟触发流程

```
系统闹钟触发（到达设定时间）
    ↓
AlarmReceiver.onReceive()
    ├─→ 安全检查：验证闹钟ID是否存在于本地数据（防止旧版本残留）
    ├─→ 播放铃声：playRingtone()
    │   ├─→ 优先使用闹钟自身设置的铃声URI
    │   └─→ 如果没有，使用 SettingsActivity 保存的默认铃声
    ├─→ 震动（如果启用）
    └─→ 启动 AlarmRingingActivity
        ├─→ 显示闹钟时间和标签
        ├─→ 继续播放铃声和震动
        └─→ 等待用户操作：
            ├─→ "稍后提醒" → snoozeAlarm() → 重新调度系统闹钟（间隔N分钟后）
            └─→ "关闭" → 停止铃声 → （可选）删除闹钟（如果设置了deleteAfterDismiss）
```

### 2.3 节假日跳过逻辑

```
AlarmDataManager.scheduleAlarm()
    ↓
检查条件：alarm.isSkipHolidays() || global_skip_holidays（从settings_prefs读取）
    ↓
如果是 true，循环查找下一个非节假日：
    while (HolidayUtil.isHoliday(calendar) && checkedDays < 365) {
        calendar.add(Calendar.DAY_OF_MONTH, 1);
    }
    ↓
HolidayUtil.isHoliday()
    └─→ 调用 API: http://api.haoshenqi.top/holiday?date=YYYY-MM-DD
        └─→ 解析 JSON，判断 status == 3（法定节假日）
```

---

## 三、关键类详细说明

### 3.1 Alarm.java（数据模型）

**作用**：闹钟的实体类，存储所有闹钟相关数据

**关键字段**：
- `id`: 唯一标识（使用时间戳）
- `hour/minute`: 闹钟时间
- `repeatDays[]`: 重复星期设置（7个布尔值）
- `skipHolidays`: 是否跳过节假日
- `deleteAfterDismiss`: 关闭后是否删除
- `snoozeAnnounce`: 稍后提醒时是否报时

**默认值策略**：
- 默认时间：**当前时间**（而非固定的08:00），避免重装后出现默认闹钟

### 3.2 AlarmDataManager.java（数据管理层）

**作用**：管理闹钟的持久化存储和系统闹钟调度

**核心方法**：

1. **addAlarm(Alarm)**
   - 保存到 SharedPreferences（使用Gson序列化为JSON）
   - 调用 `scheduleAlarm()` 注册系统闹钟

2. **updateAlarm(Alarm)**
   - 更新 SharedPreferences 中的闹钟数据
   - 先取消旧闹钟，再重新调度（如果启用）

3. **scheduleAlarm(Alarm)**
   - 创建 PendingIntent 指向 AlarmReceiver
   - 计算闹钟触发时间
   - **节假日跳过逻辑**：如果启用跳过，循环查找下一个非节假日
   - 重复闹钟：使用 `setRepeating()`，每天重复
   - 单次闹钟：使用 `setExactAndAllowWhileIdle()` 确保精确触发

4. **clearAllAlarms()**
   - 遍历所有闹钟，取消系统闹钟
   - 清空 SharedPreferences 中的闹钟数据

### 3.3 AlarmReceiver.java（广播接收器）

**作用**：接收系统闹钟触发的广播，启动响铃流程

**关键逻辑**：

1. **安全验证**（防止旧版本残留的系统闹钟）：
   ```java
   AlarmDataManager alarmDataManager = new AlarmDataManager(context);
   Alarm found = null;
   for (Alarm a : alarmDataManager.getAlarms()) {
       if (a.getId() == alarmId) {
           found = a;
           break;
       }
   }
   if (found == null) {
       // 如果找不到，忽略本次响铃
       return;
   }
   ```

2. **铃声选择优先级**：
   - 优先使用 `intent.getStringExtra("ringtone_uri")`
   - 如果为空，调用 `getDefaultRingtoneUri()` 获取设置中的默认铃声
   - 如果还没有，使用系统默认铃声

3. **启动 AlarmRingingActivity**：
   - 传递闹钟信息（id, label, time等）
   - 设置 `FLAG_ACTIVITY_NEW_TASK` 确保从后台启动

### 3.4 AlarmRingingActivity.java（响铃界面）

**作用**：显示响铃界面，处理用户交互（稍后提醒/关闭）

**关键功能**：

1. **唤醒设备**：
   - 设置窗口标志（FLAG_TURN_SCREEN_ON, FLAG_SHOW_WHEN_LOCKED等）
   - 获取 WakeLock 保持唤醒

2. **播放铃声和震动**：
   - 从 Intent 获取铃声URI，优先使用闹钟自身设置，否则使用默认铃声
   - 使用 Ringtone 或 MediaPlayer 播放
   - 根据设置决定是否震动

3. **稍后提醒功能**：
   - 读取全局设置（间隔时间、最大次数）
   - 检查当前闹钟的稍后提醒次数是否已达上限
   - 如果启用报时（`alarm.isSnoozeAnnounce()`），使用 TextToSpeech 播报当前时间
   - 调用 `snoozeAlarm()` 重新调度系统闹钟（N分钟后）

4. **关闭功能**：
   - 停止铃声和震动
   - 如果 `alarm.isDeleteAfterDismiss()` 为 true，删除闹钟

### 3.5 MainActivity.java（主界面）

**作用**：显示闹钟列表，提供添加、编辑、删除功能

**核心功能**：

1. **列表展示**：
   - 使用 RecyclerView + AlarmAdapter
   - 显示时间、重复设置、标签、跳过节假日标记

2. **滑动删除**：
   - 使用 ItemTouchHelper 实现左右滑动
   - 滑动后显示确认对话框

3. **开关切换**：
   - 点击开关 → `onToggleAlarm()` → `AlarmDataManager.updateAlarm()`
   - 更新后立即刷新列表以更新颜色（启用=黑色，禁用=灰色）

4. **生命周期**：
   - `onResume()` 时刷新列表（从设置页返回时确保数据最新）

### 3.6 EditAlarmActivity.java（编辑界面）

**作用**：添加或编辑单个闹钟的详细设置

**关键功能**：

1. **时间选择**：NumberPicker（小时/分钟）

2. **重复设置**：对话框选择星期几（使用Chip组件）

3. **提醒方式**：铃声选择器 + 震动开关

4. **稍后提醒设置**：
   - 点击跳转到 `SnoozeSettingsActivity`
   - 从 SharedPreferences 读取全局设置并显示

5. **单个闹钟的开关**：
   - `switchSkipHolidays`：是否跳过节假日（覆盖全局设置）
   - `switchDeleteAfterDismiss`：关闭后删除
   - `switchSnoozeAnnounce`：稍后提醒时是否报时

6. **保存逻辑**：
   - 新建：`AlarmDataManager.addAlarm()`
   - 编辑：`AlarmDataManager.updateAlarm()`

### 3.7 SettingsActivity.java（设置界面）

**作用**：管理全局设置

**全局设置项**：

1. **默认铃声**：
   - 保存到 `settings_prefs` 的 `default_ringtone_uri`
   - 闹钟没有设置铃声时使用

2. **全局跳过节假日**：
   - 保存到 `settings_prefs` 的 `global_skip_holidays`
   - 所有闹钟都会检查此设置（除非单个闹钟自身设置了跳过）

3. **稍后提醒设置**：
   - 跳转到 `SnoozeSettingsActivity`

4. **清空数据**：
   - 调用 `AlarmDataManager.clearAllAlarms()`
   - 清空 `settings_prefs`
   - 返回主界面刷新列表

### 3.8 HolidayUtil.java（节假日工具）

**作用**：查询外部API判断指定日期是否为法定节假日

**API说明**：
- 接口：`http://api.haoshenqi.top/holiday?date=YYYY-MM-DD`
- 响应：`{"date": "2019-05-01", "status": 3, ...}`
- status含义：
  - 0: 普通工作日
  - 1: 周末双休日
  - 2: 需要补班的工作日
  - **3: 法定节假日**（我们要判断的）

**实现细节**：
- 使用 HttpURLConnection 同步请求（注意：应在后台线程调用，但当前实现在主线程，可能阻塞）
- 解析 JSON，判断 `status == 3`
- 网络异常时返回 `null`，调用方会回退为 `false`（不跳过）

---

## 四、SharedPreferences 数据结构

### 4.1 alarm_prefs（闹钟数据）

```
KEY_ALARMS: JSON字符串
[
    {
        "id": 1234567890,
        "hour": 8,
        "minute": 0,
        "label": "起床",
        "enabled": true,
        "repeatDays": [true, true, true, true, true, false, false],
        "ringtoneUri": "content://...",
        "ringtoneName": "默认铃声",
        "vibrate": true,
        "volume": 80,
        "skipHolidays": false,
        "deleteAfterDismiss": false,
        "snoozeAnnounce": false
    },
    ...
]
```

### 4.2 settings_prefs（全局设置）

```
default_ringtone_uri: "content://..."
default_ringtone_name: "默认铃声"
global_skip_holidays: true/false
snooze_enabled: true/false
snooze_interval: 10（分钟）
snooze_count: 5（最大次数）
```

### 4.3 snooze_prefs（稍后提醒计数）

```
snooze_count_1234567890: 3（某个闹钟的稍后提醒次数）
```

---

## 五、权限说明

- `INTERNET`: 查询节假日API
- `SCHEDULE_EXACT_ALARM` / `USE_EXACT_ALARM`: 精确闹钟（Android 12+）
- `VIBRATE`: 震动
- `WAKE_LOCK`: 保持设备唤醒
- `RECEIVE_BOOT_COMPLETED`: 开机后恢复闹钟（需要实现）
- `DISABLE_KEYGUARD`: 解锁屏幕显示响铃界面
- `POST_NOTIFICATIONS`: 通知（Android 13+）

---

## 六、重要设计决策

1. **默认时间使用当前时间**：避免重装后出现默认08:00闹钟
2. **双重安全验证**：AlarmReceiver 和 AlarmRingingActivity 都检查闹钟是否存在，防止旧版本残留
3. **节假日跳过双重控制**：支持全局设置和单个闹钟设置
4. **默认铃声回退机制**：闹钟自身 → 设置中的默认 → 系统默认
5. **稍后提醒计数独立管理**：每个闹钟独立计数，避免相互影响

---

## 七、待优化点

1. **HolidayUtil 网络请求**：应在后台线程执行，避免阻塞UI
2. **开机恢复闹钟**：需要实现 BootReceiver（当前已注册但未实现逻辑）
3. **重复闹钟的节假日跳过**：当前只对单次闹钟生效，重复闹钟需要每日检查

